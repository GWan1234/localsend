// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:localsend_app/rust/api/model.dart';
import 'package:localsend_app/rust/frb_generated.dart';
import 'package:uuid/uuid.dart';

part 'webrtc.freezed.dart';

Stream<WsServerMessage> connect(
        {required String uri, required ClientInfoWithoutId info, required FutureOr<void> Function(LsSignalingConnection) onConnection}) =>
    RustLib.instance.api.crateApiWebrtcConnect(uri: uri, info: info, onConnection: onConnection);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LsSignalingConnection>>
abstract class LsSignalingConnection implements RustOpaqueInterface {
  Future<RtcReceiveController> acceptOffer({required List<String> stunServers, required WsServerSdpMessage offer, PinConfig? pin});

  Future<RtcSendController> sendOffer({required List<String> stunServers, required UuidValue target, required List<FileDto> files});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RTCFileReceiver>>
abstract class RtcFileReceiver implements RustOpaqueInterface {
  Future<String> getFileId();

  Stream<Uint8List> receive();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RTCFileSender>>
abstract class RtcFileSender implements RustOpaqueInterface {
  Future<void> send({required List<int> data});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RTCReceiveController>>
abstract class RtcReceiveController implements RustOpaqueInterface {
  Future<void> decline();

  Stream<RTCFileError> listenError();

  Future<List<FileDto>> listenFiles();

  Stream<RtcFileReceiver> listenReceiving();

  Stream<RTCStatus> listenStatus();

  Future<void> sendFileStatus({required RTCSendFileResponse status});

  Future<void> sendSelection({required Set<String> selection});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RTCSendController>>
abstract class RtcSendController implements RustOpaqueInterface {
  Stream<RTCFileError> listenError();

  Future<Set<String>> listenSelectedFiles();

  Stream<RTCStatus> listenStatus();

  Future<RtcFileSender> sendFile({required String fileId});

  Future<void> sendPin({required String pin});
}

class ClientInfo {
  final UuidValue id;
  final String alias;
  final String version;
  final String? deviceModel;
  final PeerDeviceType? deviceType;
  final String fingerprint;

  const ClientInfo({
    required this.id,
    required this.alias,
    required this.version,
    this.deviceModel,
    this.deviceType,
    required this.fingerprint,
  });

  @override
  int get hashCode => id.hashCode ^ alias.hashCode ^ version.hashCode ^ deviceModel.hashCode ^ deviceType.hashCode ^ fingerprint.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClientInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          alias == other.alias &&
          version == other.version &&
          deviceModel == other.deviceModel &&
          deviceType == other.deviceType &&
          fingerprint == other.fingerprint;
}

class ClientInfoWithoutId {
  final String alias;
  final String version;
  final String? deviceModel;
  final PeerDeviceType? deviceType;
  final String fingerprint;

  const ClientInfoWithoutId({
    required this.alias,
    required this.version,
    this.deviceModel,
    this.deviceType,
    required this.fingerprint,
  });

  @override
  int get hashCode => alias.hashCode ^ version.hashCode ^ deviceModel.hashCode ^ deviceType.hashCode ^ fingerprint.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClientInfoWithoutId &&
          runtimeType == other.runtimeType &&
          alias == other.alias &&
          version == other.version &&
          deviceModel == other.deviceModel &&
          deviceType == other.deviceType &&
          fingerprint == other.fingerprint;
}

enum PeerDeviceType {
  mobile,
  desktop,
  web,
  headless,
  server,
  ;
}

class PinConfig {
  final String pin;
  final int maxTries;

  const PinConfig({
    required this.pin,
    required this.maxTries,
  });

  @override
  int get hashCode => pin.hashCode ^ maxTries.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is PinConfig && runtimeType == other.runtimeType && pin == other.pin && maxTries == other.maxTries;
}

class RTCFileError {
  final String fileId;
  final String error;

  const RTCFileError({
    required this.fileId,
    required this.error,
  });

  @override
  int get hashCode => fileId.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) || other is RTCFileError && runtimeType == other.runtimeType && fileId == other.fileId && error == other.error;
}

class RTCSendFileResponse {
  final String id;
  final bool success;
  final String? error;

  const RTCSendFileResponse({
    required this.id,
    required this.success,
    this.error,
  });

  @override
  int get hashCode => id.hashCode ^ success.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RTCSendFileResponse && runtimeType == other.runtimeType && id == other.id && success == other.success && error == other.error;
}

@freezed
sealed class RTCStatus with _$RTCStatus {
  const RTCStatus._();

  const factory RTCStatus.sdpExchanged() = RTCStatus_SdpExchanged;
  const factory RTCStatus.connected() = RTCStatus_Connected;
  const factory RTCStatus.pinRequired() = RTCStatus_PinRequired;
  const factory RTCStatus.tooManyAttempts() = RTCStatus_TooManyAttempts;
  const factory RTCStatus.declined() = RTCStatus_Declined;
  const factory RTCStatus.sending() = RTCStatus_Sending;
  const factory RTCStatus.finished() = RTCStatus_Finished;
  const factory RTCStatus.error(
    String field0,
  ) = RTCStatus_Error;
}

@freezed
sealed class WsServerMessage with _$WsServerMessage {
  const WsServerMessage._();

  const factory WsServerMessage.hello({
    required ClientInfo client,
    required List<ClientInfo> peers,
  }) = WsServerMessage_Hello;
  const factory WsServerMessage.joined({
    required ClientInfo peer,
  }) = WsServerMessage_Joined;
  const factory WsServerMessage.left({
    required UuidValue peerId,
  }) = WsServerMessage_Left;
  const factory WsServerMessage.offer(
    WsServerSdpMessage field0,
  ) = WsServerMessage_Offer;
  const factory WsServerMessage.answer(
    WsServerSdpMessage field0,
  ) = WsServerMessage_Answer;
  const factory WsServerMessage.error({
    required int code,
  }) = WsServerMessage_Error;
}

class WsServerSdpMessage {
  final ClientInfo peer;
  final String sessionId;
  final String sdp;

  const WsServerSdpMessage({
    required this.peer,
    required this.sessionId,
    required this.sdp,
  });

  @override
  int get hashCode => peer.hashCode ^ sessionId.hashCode ^ sdp.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WsServerSdpMessage && runtimeType == other.runtimeType && peer == other.peer && sessionId == other.sessionId && sdp == other.sdp;
}
